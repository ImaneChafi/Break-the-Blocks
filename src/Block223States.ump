class PlayedGame {

  depend java.awt.geom.QuadCurve2D;
  depend java.awt.geom.Rectangle2D;

  // State Machine
  
  playStatus {
    Ready {
      entry / { doSetup(); }
      play -> Moving;
    }
    Moving {
      pause -> Paused;
      move [hitPaddle()] / { doHitPaddleOrWall(); } -> Moving;
      move [isOutOfBoundsAndLastLife()] / { doOutOfBounds(); } -> GameOver;
      move [isOutOfBounds()] / { doOutOfBounds(); } -> Paused;
      move [hitLastBlockAndLastLevel()] / { doHitBlock(); } -> GameOver;
      move [hitLastBlock()] / { doHitBlockNextLevel(); } -> Ready;
      move [hitBlock()] / { doHitBlock(); } -> Moving;
      move [hitWall()] / { doHitPaddleOrWall(); } -> Moving;
      move / { doHitNothingAndNotOutOfBounds(); } -> Moving;
    }
    Paused {
      play -> Moving;
    }
    GameOver {
      entry / { doGameOver(); }
    }
  }
  
  // Guards
  
 /**
   * This returns true if the ball hits the paddle.
   * @author Kelly Ma
   * @return Whether or not the ball hits paddle
  */
  private boolean hitPaddle() {
    BouncePoint bp = calculateBouncePointPaddle();
    setBounce(bp);
    if (bp != null) return true;
    return false;
  }

  /**
   * This returns true if the ball is out of bounds and is last life.
   * @author Georges Mourant
   * @return if ball is out of bounds and last life
  */
  private boolean isOutOfBoundsAndLastLife() {
    boolean outOfBounds = false;
    if(lives == 1) outOfBounds = isBallOutOfBounds();
    return outOfBounds;
  }
  
  /**
   * This returns true if the ball is out of bounds.
   * @author Georges Mourant
   * @return if ball is out of bounds and last life
  */
  private boolean isOutOfBounds() {
    return isBallOutOfBounds();
  }
  
  private boolean hitLastBlockAndLastLevel() {
    Game game = this.getGame();
	int nrLevels = game.numberOfLevels();

	this.setBounce(null);

	if(nrLevels == currentLevel) {
		int nrBlocks = numberOfBlocks();
		if(nrBlocks == 1) {
			PlayedBlockAssignment block = this.getBlock(0);
			BouncePoint bp = calculateBouncePointBlock(block);
			setBounce(bp);
			return (bp!=null);
		}
	}
    return false;
  }
  
  /**
  * This method returns true if the ball hits the last block.
  * @author Mathieu Bissonnette
  */
  
  private boolean hitLastBlock(){
    int nrBlocks = numberOfBlocks();
    setBounce(null);
    if (nrBlocks == 1) {
        PlayedBlockAssignment block = getBlock(0);
        BouncePoint bp = calculateBouncePointBlock(block);
        setBounce(bp);
        return true;
    }
    return false;
  }
  
  /**
  * This method returns true if the ball hits a block.
  * @author Mathieu Bissonnette
  */
  
  private boolean hitBlock() {
    int nrBlocks = numberOfBlocks();
    setBounce(null);
    for (int i = 0; i <= (nrBlocks - 1); i++) {
        PlayedBlockAssignment block = getBlock(i);
        BouncePoint bp = calculateBouncePointBlock(block);
        bounce = getBounce();
        boolean closer = isCloser(bp, bounce);
        if (closer)
            setBounce(bp);
    }
    return (getBounce() != null);
  }
  
   /**
   * This returns true if the ball hits a wall.
   * @author Kelly Ma
   * @return Whether or not the ball hits wall
  */
  private boolean hitWall() {
    BouncePoint bp = calculateBouncePointWall();
    setBounce(bp);
    if (bp != null) return true;
    return false;
  }
  
  // Actions
  
/**
 	 * Public method used to get a random number
 	 * @author https://dzone.com/articles/random-number-generation-in-java
 	 * @return double value
 	 * */
 	public static int getRandomInt(){
 	    Random rand = new Random();
 		//obtain number between 0-49
 	    int x = rand.nextInt(50);
 	    return x;
 	}
 	public static int getRandomInt2(){
 	    Random rand = new Random();
 		//obtain number between 0-4
 	    int x = rand.nextInt(4);
 	    return x;
 	}
	
		/**
 	 * This private method returns the setup for the Played Game
 	 * by resetting the ball positions and paddle positions and by
 	 * adding random block positions if there is less blocks than the 
 	 * set number of blocks/level.
 	 * @author Imane Chafi 
 	 * */
 	private void doSetup() {
		this.resetCurrentBallX();
		this.resetCurrentBallY();
		this.resetBallDirectionX();
		this.resetBallDirectionY();
		this.resetCurrentPaddleX();
		this.getGame();
		Level level = game.getLevel(getCurrentLevel() - 1);
		List<BlockAssignment> assignments = level.getBlockAssignments();

		for (BlockAssignment a : assignments) {
			new PlayedBlockAssignment(
					Game.WALL_PADDING + (Block.SIZE + Game.COLUMNS_PADDING) * (a.getGridHorizontalPosition() - 1),
					Game.WALL_PADDING + (Block.SIZE + Game.ROW_PADDING) * (a.getGridVerticalPosition() - 1),
					a.getBlock(), this);

		}
		// Initializing the x and y variables before the while loop
		int x = getRandomInt();
		int y = getRandomInt();
		while (numberOfBlocks() < game.getNrBlocksPerLevel()) {
			// if chosen, try next position starting from randomly chosen position
			BlockAssignment taken = level.findBlockAssignment(x, y);
			if (taken != null) {
				x++;
				if (x > 15) {
					y++;
					x = 1;
				}
				if (y > 15)
					y = 1;

			}
			// going to the right, then next row until last row
			// then 1/1 until empty position found.
			// convert to x/y coordinates
			x = Game.WALL_PADDING + (Block.SIZE + Game.COLUMNS_PADDING) * (x - 1);
			y = Game.WALL_PADDING + (Block.SIZE + Game.ROW_PADDING) * (y - 1);

			new PlayedBlockAssignment(x, y, game.getRandomBlock(), this);
		}
	}
  
  private void doHitPaddleOrWall() {
    bounceBall();
  }

  private void doOutOfBounds() {
    setLives(lives-1);
    resetCurrentBallX();
    resetCurrentBallY();
    resetBallDirectionX();
    resetBallDirectionY();
    resetCurrentPaddleX();
  }

  private void doHitBlock() {
    int score = getScore();
    BouncePoint bounce = getBounce();
    PlayedBlockAssignment pblock = bounce.getHitBlock();
    Block block = pblock.getBlock();
    int bscore = block.getPoints();
    setScore(score + bscore);
    pblock.delete();
    bounceBall();
  }

  private void doHitBlockNextLevel() {
		   doHitBlock();
		   int level = getCurrentLevel();
		   setCurrentLevel(level+1);
		   setCurrentPaddleLength(getGame().getPaddle().getMaxPaddleLength() -
				   (getGame().getPaddle().getMaxPaddleLength() - getGame().getPaddle().getMinPaddleLength())/
				   (getGame().numberOfLevels() - 1) * (getCurrentLevel() - 1));
		   setWaitTime(INITIAL_WAIT_TIME * Math.pow(getGame().getBall().getBallSpeedIncreaseFactor(),
				   (getCurrentLevel() - 1)));
  }

 /**
   * This method is performed when the ball is bounced after hitting the paddle, block, or wall.
   * @author Kelly Ma
  */
	private void bounceBall() {
		BouncePoint bp = getBounce(); // Calculate bounce point
		double newBallDirectionX = ballDirectionX; // Create variables to store new X & Y directions
		double newBallDirectionY = ballDirectionY;
		if (bp.getDirection().equals(BouncePoint.BounceDirection.FLIP_Y)) { // Check direction at bounce point
			newBallDirectionY = -1 * ballDirectionY; // Flip Y direction
			if (ballDirectionX * ballDirectionY < 0) { // Check if product of X and Y direction is < 0
				newBallDirectionX = ballDirectionX + 0.1 * newBallDirectionY;
			} else {
				newBallDirectionX = ballDirectionX + 0.1 * ballDirectionY;
			}
		} else if (bp.getDirection().equals(BouncePoint.BounceDirection.FLIP_X)) { // Check direction at bounce point
			newBallDirectionX = -1 * ballDirectionX; // Flip X direction
			if (ballDirectionX * ballDirectionY < 0) { // Check if product of X and Y direction is < 0
				newBallDirectionY = ballDirectionY + 0.1 * newBallDirectionX;
			} else {
				newBallDirectionY = ballDirectionY + 0.1 * ballDirectionX;
			}
		} else if (bp.getDirection().equals(BouncePoint.BounceDirection.FLIP_BOTH)) { // Check if both are flipped
			newBallDirectionX = -1 * ballDirectionX;
			newBallDirectionY = -1 * ballDirectionY;
		}

		setCurrentBallY(bp.getY()); // Set current ball positions
		setCurrentBallX(bp.getX());
		setBallDirectionX(newBallDirectionX); // Set new ball directions
		setBallDirectionY(newBallDirectionY);

		if (bp.hasHitBlock()) { // Check if the bounce point has a block
			bounce.setHitBlock(null);
		}
	}

 /*Method calculateBouncePointPaddle sets the flip states of the ball 
  when it hits the paddle.
  @author Imane Chafi
  @return BouncePoint*/
  
   private BouncePoint calculateBouncePointPaddle(){
	   /* STEP 1 : Check  if  the  ball  segment (the  segment  determined  by 
	   the  current  position  of  the  ball  and  the  new position of the 
	   ball) intersects with the full box (A, B, C, E,F)*/
	   
	   int radius = Ball.BALL_DIAMETER/2; // Get ball radius
	   BouncePoint bp = null; // Initialize ball's bounce point
	   double currentBallX = this.getCurrentBallX(); // Find ball coordinates
	   double currentBallY = this.getCurrentBallY();
	   double nextBallX = currentBallX + this.getBallDirectionX();
	   double nextBallY = currentBallY + this.getBallDirectionY();
	   
	   // Find rectangles for calculation purposes
	 	Rectangle2D.Double rectA = new Rectangle2D.Double(currentPaddleX, Paddle.VERTICAL_DISTANCE - radius, Paddle.PADDLE_WIDTH, radius ); // Left wall of play area
	 	Rectangle2D.Double rectB = new Rectangle2D.Double(currentPaddleX - radius, Paddle.VERTICAL_DISTANCE, radius, radius); // Top wall of play area
	 	Rectangle2D.Double rectC = new Rectangle2D.Double(currentPaddleX + Paddle.PADDLE_WIDTH, Paddle.VERTICAL_DISTANCE, radius, radius); // Right wall of play area
	 	Rectangle2D.Double rectE = new Rectangle2D.Double(currentPaddleX - radius, Paddle.VERTICAL_DISTANCE - radius, radius, radius); // Right wall of play area
	 	Rectangle2D.Double rectF = new Rectangle2D.Double(currentPaddleX + Paddle.PADDLE_WIDTH, Paddle.VERTICAL_DISTANCE - radius, radius, radius); // Right wall of play area
	 // create new QuadCurve2D.Float for E 
		QuadCurve2D curveE = new QuadCurve2D.Float();
		curveE.setCurve(currentPaddleX - radius, Paddle.VERTICAL_DISTANCE, currentPaddleX - ((int)(radius/(Math.sqrt(2)))), Paddle.VERTICAL_DISTANCE - ((int)(radius/(Math.sqrt(2)))), currentPaddleX, Paddle.VERTICAL_DISTANCE - radius);
	 // create new QuadCurve2D.Float for F
		QuadCurve2D curveF = new QuadCurve2D.Float();
		curveF.setCurve(currentPaddleX + Paddle.PADDLE_WIDTH + radius, Paddle.VERTICAL_DISTANCE, currentPaddleX + Paddle.PADDLE_WIDTH + ((int)(radius/(Math.sqrt(2)))), Paddle.VERTICAL_DISTANCE - ((int)(radius/(Math.sqrt(2)))), currentPaddleX + Paddle.PADDLE_WIDTH, Paddle.VERTICAL_DISTANCE - radius);
		// Check points of intersection between ball and lines
	 	boolean intersectionA = rectA.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectA
	 	boolean intersectionB = rectB.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectB
	 	boolean intersectionC = rectC.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectC
	 	boolean intersectionE = rectE.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectB
	 	boolean intersectionF = rectF.intersectsLine(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectC
	 	boolean intersectionECurve = curveE.intersects(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectB
	 	boolean intersectionFCurve = curveF.intersects(currentBallX, currentBallY, nextBallX, nextBallY); // Ball intersects rectC
	   
	 	/*STEP 2 : For A, B, C, determine the bounce point by intersecting the
	    ball segment with each of the yellow line segments of A, B,*/
	 // Create a collection of bounce points to determine which is closest
	 		List <BouncePoint> bouncePoints = new ArrayList<BouncePoint>();
	 		
	 		if (!intersectionA && !intersectionB && !intersectionC) { // Does not hit a hall at all
				return null;
			} else if (intersectionA) { // Check intersection of A 
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_Y);//X and Y position are set to the same nextBallX and nextBallY
				bouncePoints.add(bp);
			} else if (intersectionB) { // Check intersection of B 
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_X);
				bouncePoints.add(bp);
			} else if (intersectionC) { // Check intersection of C
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_X);
				bouncePoints.add(bp);
			}
	 		
	 		/*STEP  3:  For  E,  F  determine  the 
	    bounce  point  by  intersecting  the  ball  segment  
	    with  each  of the  circle  segments of E, */
			else if (intersectionE || intersectionECurve) { // Check intersection of C
				
				//Setting the curve for E : 
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_X);
				bouncePoints.add(bp);
			}
			else if (intersectionF || intersectionFCurve) { // Check intersection of C
				bp = new BouncePoint(nextBallX, nextBallY, BouncePoint.BounceDirection.FLIP_X);
				bouncePoints.add(bp);
			}
	 		
	    /*: If more than one bounce point are found, 
	    take the bounce point that is the closest to the 
	    current position of the ball. 
	    The box of the bounce point determines the bounce behavior */
	 	// Iterate through all points to find the closest one
			BouncePoint closestPoint = null;
	        for (BouncePoint bouncePoint : bouncePoints) {
	        	if (isCloser(bouncePoint, closestPoint))
	            	closestPoint = bouncePoint;
	        }

			return closestPoint; // From collection of all bounce points
	   }

	/**
	 * This method calculates the bounce point when the ball hits the wall
	 * @author Kelly Ma
	 * @return the bounce point of the wall or null
	 */
	private BouncePoint calculateBouncePointWall() {

		// Get current ball location and direction
		double currentBallX = getCurrentBallX();
		double currentBallY = getCurrentBallY();
		double dX = getBallDirectionX();
		double dY = getBallDirectionY();

		// Create a list to store all bounce points
		ArrayList<BouncePoint> bps = new ArrayList<BouncePoint>();

		// Calculate ball radius
		int radius = Ball.BALL_DIAMETER / 2;

		// Create rectangles for all the areas to be tested
		Rectangle2D.Double rectA = new Rectangle2D.Double(0, 0, radius, Game.PLAY_AREA_SIDE);
		Rectangle2D.Double rectB = new Rectangle2D.Double(0, 0, Game.PLAY_AREA_SIDE, radius);
		Rectangle2D.Double rectC = new Rectangle2D.Double(Game.PLAY_AREA_SIDE - radius, 0, radius, Game.PLAY_AREA_SIDE);

		// Check all intersections
		boolean intersectionA = rectA.intersectsLine(currentBallX, currentBallY, dX, dY);
		boolean intersectionB = rectB.intersectsLine(currentBallX, currentBallY, dX, dY);
		boolean intersectionC = rectC.intersectsLine(currentBallX, currentBallY, dX, dY);

		if (intersectionA && !intersectionB) { // Intersection A only
			bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_X));
		}
		if (intersectionA && intersectionB) { // Intersects A and B
			bps.add(new BouncePoint(radius, radius, BouncePoint.BounceDirection.FLIP_BOTH)); // Flip both directions
		}
		if (intersectionC && intersectionB) { // Intersects C and B
			bps.add(new BouncePoint(Game.PLAY_AREA_SIDE - radius, radius, BouncePoint.BounceDirection.FLIP_BOTH)); // Flip both directions
		}
		if (intersectionB && !intersectionA && !intersectionC) { // Intersects B only
			bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_Y));
		}
		if (intersectionC && !intersectionB) { // Intersects C only 
			bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_X));
		}

		// Iterate through all points to find the closest one
		// If closestPoint is not found, returns null
		BouncePoint closestPoint = null;
		for (BouncePoint bouncePoint : bps) {
			if (isCloser(bouncePoint, closestPoint))
				closestPoint = bouncePoint;
		}

		return closestPoint; // From collection of all bounce points
	}


  /**
  * This method returns the bounce point that is the closest to the ball. 
  * If there is no bouncePoint, it returns null.
  * @author Mathieu Bissonnette
  * @author Kelly Ma
  * @return the bounce point after hitting a block
  */
  
   private BouncePoint calculateBouncePointBlock(PlayedBlockAssignment block) {

		// Calculate ball radius
		int radius = Ball.BALL_DIAMETER / 2;

		// Get current ball coordinates and directions
		double currentBallX = this.getCurrentBallX();
		double currentBallY = this.getCurrentBallY();
		double dX = currentBallX + this.getBallDirectionX();
		double dY = currentBallY + this.getBallDirectionY();

		// Add rectangles for testing
		Rectangle2D.Double rectA = new Rectangle2D.Double(block.getX(), block.getY() - radius, Block.SIZE, radius);
		Rectangle2D.Double rectB = new Rectangle2D.Double(block.getX() - radius, block.getY(), radius, Block.SIZE);
		Rectangle2D.Double rectC = new Rectangle2D.Double(block.getX() + Block.SIZE, block.getY(), radius, Block.SIZE);
		Rectangle2D.Double rectD = new Rectangle2D.Double(block.getX(), block.getY() + Block.SIZE, Block.SIZE, radius);

		// Create new QuadCurve2D.Float for E
		QuadCurve2D curveE = new QuadCurve2D.Float();
		curveE.setCurve(block.getX() - Block.SIZE - radius, block.getY(),
				block.getX() - Block.SIZE - ((int) (radius / (Math.sqrt(2)))),
				block.getY() - ((int) (radius / (Math.sqrt(2)))), block.getX() - Block.SIZE, block.getY() - radius);

		// Create new QuadCurve2D.Float for F
		QuadCurve2D curveF = new QuadCurve2D.Float();
		curveF.setCurve(block.getX() + radius, block.getY(), block.getX() - ((int) (radius / (Math.sqrt(2)))),
				block.getY() - ((int) (radius / (Math.sqrt(2)))), block.getX(), block.getY() - radius);

		// Create new QuadCurve2D.Float for G
		QuadCurve2D curveG = new QuadCurve2D.Float();
		curveG.setCurve(block.getX() - Block.SIZE - radius, block.getY() - Block.SIZE,
				block.getX() - Block.SIZE + ((int) (radius / (Math.sqrt(2)))),
				block.getY() - Block.SIZE + ((int) (radius / (Math.sqrt(2)))), block.getX() - Block.SIZE,
				block.getY() - Block.SIZE - radius);

		// Create new QuadCurve2D.Float for H
		QuadCurve2D curveH = new QuadCurve2D.Float();
		curveH.setCurve(block.getX() + radius, block.getY() + Block.SIZE,
				block.getX() + radius - ((int) (radius / (Math.sqrt(2)))),
				block.getY() + Block.SIZE + ((int) (radius / (Math.sqrt(2)))), block.getX(),
				block.getY() + Block.SIZE + radius);

		// All intersections are listed below
		boolean intersectionA = rectA.intersectsLine(currentBallX, currentBallY, dX, dY);
		boolean intersectionB = rectB.intersectsLine(currentBallX, currentBallY, dX, dY);
		boolean intersectionC = rectC.intersectsLine(currentBallX, currentBallY, dX, dY);
		boolean intersectionD = rectD.intersectsLine(currentBallX, currentBallY, dX, dY);
		boolean intersectionECurve = curveE.intersects(currentBallX, currentBallY, dX, dY);
		boolean intersectionFCurve = curveF.intersects(currentBallX, currentBallY, dX, dY);
		boolean intersectionGCurve = curveE.intersects(currentBallX, currentBallY, dX, dY);
		boolean intersectionHCurve = curveF.intersects(currentBallX, currentBallY, dX, dY);

		// Create a list to store all bounce points found
		ArrayList<BouncePoint> bps = new ArrayList<BouncePoint>();

		if (intersectionA) { // Check intersection A
			bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_Y));
		}
		if (intersectionB) { // Check intersection B
			bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_X));
		}
		if (intersectionC) { // Check intersection CLine2D.Double ballPath = new Line2D.Double(currentBallX, currentBallY, dX, dY);
			bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_X));
		}
		if (intersectionD) { // Check intersection D
			bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_Y));
		}
		if (intersectionECurve) { // Check curve intersection E
			if (dX < 0) { // Ball approaches from the right
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_Y));
			} else if (dX > 0) { // Ball approaches from the left
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_X));
			} else { // Ball approaches dead-on
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_BOTH));
			}
		}
		if (intersectionFCurve) { // Check curve intersection F
			if (dX < 0) { // Ball approaches from the right
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_X));
			} else if (dX > 0) { // Ball approaches from the left
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_Y));
			} else { // Ball approaches dead-on
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_BOTH));
			}
		}
		if (intersectionGCurve) { // Check curve intersection G
			if (dX < 0) { // Ball approaches from the right
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_Y));
			} else if (dX > 0) { // Ball approaches from the left
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_X));
			} else { // Ball approaches dead-on
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_BOTH));
			}
		}
		if (intersectionHCurve) { // Check curve intersection H
			if (dX < 0) { // Ball approaches from the right
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_X));
			} else if (dX > 0) { // Ball approaches from the left
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_Y));
			} else { // Ball approaches dead-on
				bps.add(new BouncePoint(dX, dY, BouncePoint.BounceDirection.FLIP_BOTH));
			}
		}
	
		// Iterate through all points to find the closest one
		// If closestPoint is not found, returns null
		BouncePoint closestPoint = null;
		for (BouncePoint bouncePoint : bps) {
			if (isCloser(bouncePoint, closestPoint))
				closestPoint = bouncePoint;
		}

		return closestPoint; // From collection of all bounce points
	}
  
  /**
  * This method returns true if pointA exists and is closer to the ball than pointB.
  * @author Mathieu Bissonnette
  */
  
  private boolean isCloser(BouncePoint pointA, BouncePoint pointB) {
       // Verify if one of the point is null.
       if (pointA == null) {
           return false;
       }
       if (pointB == null) {
           return true;
       }   
       // Calculate the distances and check for the smallest one.
       double distanceA = Math.sqrt(Math.pow(currentBallX-pointA.getX(), 2) + Math.pow(currentBallY-pointA.getY(), 2));
       double distanceB = Math.sqrt(Math.pow(currentBallX-pointB.getX(), 2) + Math.pow(currentBallY-pointB.getY(), 2));
       return (distanceA < distanceB);
  }

 /*Method if the ball doesn't hit anything and stays in bounds
  @author Imane Chafi
  */

   private void doHitNothingAndNotOutOfBounds(){
    double x = this.getCurrentBallX();
    double y = this.getCurrentBallY();
    double dx = this.getBallDirectionX();
    double dy = this.getBallDirectionY();
    this.setCurrentBallX(x+dx);
    this.setCurrentBallY(y+dy);
  }

  /**
   * This performs all the required actions for ending the game.
   * @author Georges Mourant
  */
  private void doGameOver() {
    block223 = getBlock223();
    Player p = getPlayer();
    if(p != null){
      game = getGame();
      HallOfFameEntry hofe = new HallOfFameEntry(score, playername, p, game, block223);
      game.setMostRecentEntry(hofe);
    }
    delete();
  }

  // Guard Helper methods

  /**
   * This returns true if the ball is out of bounds.
   * @author Georges Mourant
   * @return if ball is out of bounds
  */
  private boolean isBallOutOfBounds(){
    double ballBottomY = getCurrentBallY() + Ball.BALL_DIAMETER;
    double paddleTopY = getCurrentPaddleY();
    return (paddleTopY < ballBottomY);
  }
  
}